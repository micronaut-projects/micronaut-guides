= @guideTitle@

@guideIntro@

Authors: @authors@

Micronaut Version: @micronaut@

include::{commondir}/common-gettingStarted.adoc[]

In this guide, we are going to create two microservices that will use https://www.rabbitmq.com/[RabbitMQ] to communicate
each other in an asynchronous and decoupled way.

____
RabbitMQ is an open-source message-broker software that originally implemented the Advanced Message Queuing Protocol (AMQP)
and has since been extended with a plug-in architecture to support Streaming Text Oriented Messaging Protocol (STOMP),
Message Queuing Telemetry Transport (MQTT), and other protocols.
____


include::{commondir}/common-requirements.adoc[]

include::{commondir}/common-completesolution.adoc[]

== Writing the app

Let's describe the microservices you are going to build through the tutorial.

* `books` - It returns a list of books. It uses a domain consisting of a book name and isbn. It also publishes a message in
RabbitMQ every time a book is accessed.

* `analytics` - It connects to RabbitMQ to update the analytics for every book (a counter). It also exposes an endpoint
to get the analytics.

include::{commondir}/common-annotationprocessors.adoc[]

=== Books microservice

Create the `books` microservice:

`mn create-app example.micronaut.books`

The previous command creates a folder named `books` and a Micronaut app inside it with default package:
`example.micronaut`.

Create a `BookController` class to handle incoming HTTP requests into the `books` microservice:

source:BookController[app=books]

<1> The class is defined as a controller with the http://docs.micronaut.io/latest/api/io/micronaut/http/annotation/Controller.html[@Controller]
annotation mapped to the path `/books`
<2> Inject `BookService` using constructor injection.
<3> The `@Get` annotation is used to map the `listAll` method to an HTTP GET request on `/books`.
<4> The `@Get` annotation is used to map the `findBook` method to an HTTP GET request on `/books/{isbn}`.

The previous controller responds a `List<Book>`. Create the `Book` POJO:

source:Book[app=books]

To keep this guide simple there is no database persistence, and the list of books is kept in memory in `BookService`:

source:BookService[app=books]

=== Analytics microservice

Create the `analytics` microservice:

`mn create-app example.micronaut.analytics`

To keep this guide simple there is no database persistence, and the books analytics is kept in memory in `AnalyticsService`:

source:AnalyticsService[app=analytics]

<1> Keep the books analytics in memory.
<2> Initialize and update the analytics for the book passed as parameter.
<3> Return all the analytics.

The previous service responds a `List<BookAnalytics>`. Create the `BookAnalytics` POJO:

source:BookAnalytics[app=analytics]

Write a test:

test:AnalyticsServiceTest[app=analytics]

<1> Starting with Micronaut 1.1.0 `micronaut-test-junit5` is added automatically to `build.gradle` (or `pom.xml`) when
creating an application with the CLI. For more information take a look https://micronaut-projects.github.io/micronaut-test/latest/guide/index.html[at the documentation].
<2> Just inject the collaborator and `@MicronautTest` will take care of everything.

Create a Controller to expose the analytics:

source:AnalyticsController[app=analytics]

<1> Just expose the analytics.

[NOTE]
====
The application doesn't expose the method `updateBookAnalytics` created in `AnalyticsService`. This method will be invoked
when reading messages from RabbitMQ.
====

To run the tests:

:exclude-for-build:maven

[source, bash]
----
analytics $ ./gradlew test
----

:exclude-for-build:

:exclude-for-build:gradle

[source, bash]
----
analytics $ ./mvnw test
----

:exclude-for-build:


Finally edit `application.yml` to run the application on a different port that `books` microservice.

resource:application.yml[app=analytics,tag=port]

<1> Start the Micronaut microservice on port 8081.


== Running the app

Run `books` microservice:

:exclude-for-build:maven

[source,bash]
----
books $ ./gradlew run

16:35:55.614 [main] INFO  io.micronaut.runtime.Micronaut - Startup completed in 576ms. Server Running: http://localhost:8080
----

Run `analytics` microservice:

[source,bash]
----
analytics $ ./gradlew run

16:35:55.614 [main] INFO  io.micronaut.runtime.Micronaut - Startup completed in 623ms. Server Running: http://localhost:8081
----

:exclude-for-build:

:exclude-for-build:gradle

[source,bash]
----
books $ ./mvnw mn:run

16:35:55.614 [main] INFO  io.micronaut.runtime.Micronaut - Startup completed in 576ms. Server Running: http://localhost:8080
----

Run `analytics` microservice:

[source,bash]
----
analytics $ ./mvnw mn:run

16:35:55.614 [main] INFO  io.micronaut.runtime.Micronaut - Startup completed in 623ms. Server Running: http://localhost:8081
----

:exclude-for-build:


You can run a `curl` command to test the application:

[source, bash]
----
$ curl http://localhost:8080/books
[{"isbn":"1491950358","name":"Building Microservices"},{"isbn":"1680502395","name":"Release It!"},{"isbn":"0321601912","name":"Continuous Delivery"}]

$ curl http://localhost:8080/books/1491950358
{"isbn":"1491950358","name":"Building Microservices"}

$ curl http://localhost:8081/analytics
[]
----

Please note that getting the analytics returns an empty list because the applications are not communicating to each other (yet).



== RabbitMQ and Micronaut

=== Install RabbitMQ via Docker

The fastest way to start using https://hub.docker.com/_/rabbitmq/[RabbitMQ is via Docker]:

[source,bash]
----
docker run --rm -it \
        -p 5672:5672 \
        -p 15672:15672 \
        rabbitmq:3.8.12-management
----

Alternatively you can https://www.rabbitmq.com/download.html[install and run a local RabbitMQ instance].


=== Books microservice

Add `rabbitmq` dependency.

dependency:micronaut-rabbitmq[groupId=io.micronaut.rabbitmq]

By default Micronaut will connect to a RabbitMQ instance running on `localhost` so it is not necessary to add anything
to `application.yml`. In case you want to change the configuration, add the following:

resource:application.yml[app=books,tag=rabbitmq]


==== Create RabbitMQ exchange, queue and binding

Before being able to send and receive messages using RabbitMQ it is necessary to define the exchange, queue and binding.
One option is create them directly in the RabbitMQ Admin UI available on `http://localhost:15672`.Use `guest` for both
username and password.

Another option is create them programatically with Micronaut.Create the class `ChannelPoolListener`:

source:ChannelPoolListener[app=books]

<1> Define an exchange named `micronaut`.From the producer point of view everything is sent to the exchange with the
appropriate routing key
<2> Define a queue named `analytics`.The consumer will listen for messages in that queue.
<3> Define a binding between the exchange and the queue using the routing key `analytics`.


==== Create RabbitMQ client (producer)

Let's create an interface to send messages to RabbitMQ. Micronaut will implement the interface at compilation time:

source:AnalyticsClient[app=books]

<1> Set the exchange used to send the messages.
<2> Set the routing key.
<3> Send the `Book` POJO. Micronaut will automatically convert it to JSON before sending it.


==== Send Analytics information automatically

Sending a message to RabbitMQ is as simple as injecting `AnalyticsClient` and calling `updateAnalytics` method. The goal
is to do it automatically every time a book is returned, i.e., every time there is a call to `http://localhost:8080/books/{isbn}`.
To achieve this we are going to create an https://docs.micronaut.io/latest/guide/index.html#filters[Http Server Filter].
Create the file `AnalyticsFilter`:

source:AnalyticsFilter[app=books]

<1> Annotate the class with `@Filter` and define the ANT Matcher pattern to intercept all the calls to the desire URI.
<2> The class needs to implement `HttpServerFilter`.
<3> Constructor injection for RabbitMQ `AnalyticsClient`.
<4> Override `doFilter` method.
<5> Execute the request. This will call the controller action.
<6> Get the response from the controller and return the body as a `Book`.
<7> If the book is found, use RabbitMQ client to send a message.



=== Analytics microservice

Add `rabbitmq` dependency.

dependency:micronaut-rabbitmq[groupId=io.micronaut.rabbitmq]


==== Create RabbitMQ exchange, queue and binding

As we already did in Books Microservice, let's create the class `ChannelPoolListener` to define the exchange, queue
and binding:

source:ChannelPoolListener[app=analytics]

TIP: Instead of copy-paste the class in every project it would be better to create a new Gradle (or Maven) module and
share it among all the microservices.


==== Create RabbitMQ consumer

Create a new class to act as a consumer of the messages sent to RabbitMQ by the Books Microservice. Micronaut will
implement the consumer at compile time. Create `AnalyticsListener`:

source:AnalyticsListener[app=analytics]

<1> Do not load this bean for the test environment. This enable us to run the tests without having a RabbitMQ instance running.
<2> Annotate the class with `@RabbitListener` to indicate that this bean will consume messages from RabbitMQ.
<3> Constructor injection for `AnalyticsService`.
<4> Annotate the method with `@Queue`. This listener will listen to messages in `analytics` queue.
<5> Call the previously created method to update the analytics for the book.



=== Running the app

Run `books` microservice:

:exclude-for-build:maven

[source,bash]
----
books $ ./gradlew run

16:35:55.614 [main] INFO  io.micronaut.runtime.Micronaut - Startup completed in 576ms. Server Running: http://localhost:8080
----

:exclude-for-build:

:exclude-for-build:gradle

[source,bash]
----
books $ ./mvnw mn:run

16:35:55.614 [main] INFO  io.micronaut.runtime.Micronaut - Startup completed in 576ms. Server Running: http://localhost:8080
----

:exclude-for-build:


Execute a `curl` request to get one book:

[source, bash]
----
$ curl http://localhost:8080/books/1491950358
{"isbn":"1491950358","name":"Building Microservices"}
----

Open RabbitMQ Admin UI on `http://localhost:15672` and use `guest` for both username and password. Select `queues` and
`analytics` queue. You can see that there is a message in the queue.

image::rabbitmq-message.png[]

Expand the "Get messages" option and get one message. You can see all the information: `exchange`, `routing key, and the
`payload` serialized to json:

image::rabbitmq-message-detail.png[]


Run `analytics` microservice:


:exclude-for-build:maven

[source,bash]
----
analytics $ ./gradlew run

16:35:55.614 [main] INFO  io.micronaut.runtime.Micronaut - Startup completed in 623ms. Server Running: http://localhost:8081
----

:exclude-for-build:

:exclude-for-build:gradle

[source,bash]
----
analytics $ ./mvnw mn:run

16:35:55.614 [main] INFO  io.micronaut.runtime.Micronaut - Startup completed in 623ms. Server Running: http://localhost:8081
----

:exclude-for-build:


The application will consume and process the message automatically after the startup. Go to RabbitMQ Admin UI and check
that the message has been consumed:

image::rabbitmq-message-consumed.png[]


Now, run a `curl` to get the analytics:

[source, bash]
----
$ curl http://localhost:8081/analytics
[{"bookIsbn":"1491950358","count":1}]
----


include::{commondir}/common-graal-with-plugins.adoc[]

:exclude-for-languages:groovy

Start the native images for the two microservices and run the same `curl` request as before to check that everything works with GraalVM.

:exclude-for-languages:


== Next steps

Read more about https://micronaut-projects.github.io/micronaut-rabbitmq/latest/guide/[RabbitMQ support] inside Micronaut.

