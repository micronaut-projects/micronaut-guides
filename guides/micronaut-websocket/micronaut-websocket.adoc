common:header.adoc[]

The https://datatracker.ietf.org/doc/html/rfc6455[WebSocket Protocol] allows for web browsers to establish interactive sessions with a server that are event-driven. This technology is ideal for applications that need state changes without the overhead and latency of polling the server. The article https://www.linode.com/docs/guides/introduction-to-websockets/["Introduction to WebSockets"] explains the benefits of WebSocket in more depth along with a discussion of the client-side WebSocket API.

This guide will take you through the creation of an event-driven chat application utilizing Mircronaut WebSocket.

common:completesolution.adoc[]

common:create-app-features.adoc[]

=== Chat server

Our chat server is very simple. It merely allows you to connect and broadcast messages to subscribers of the topic. There's also a special topic called "all" that can make announcements and receive messages from all topics.
source:ChatServer[]
<1> Create the WebSocket along with path parameters for the topic and username
<2> The WebSocket broadcaster which is set from the contructor where the broadcaster is injected
<3> Event for when a client opens a WebSocket connection
<4> Our chat server will have a special topic called "all" that can make announcements and receive messages from all topics
<5> Event for when a client sends a message using WebSocket
<6> Event for when a client closes a WebSocket connection
<7> A predicate to keep messages within topics yet also enable the special "all" topic

=== Chat client

source:ChatClientEndpoint[]
<1> This annotation is required for the client WebSocket
<2> Store all the chat messages chronologically
<3> Binds to the WebSocket "onOpen" event
<4> Binds to the WebSocket "onMessage" event
<5> Add messages to our history
<6> Binds to the WebSocket "onClose" event
<7> Any method name that start with (or equals) "broadcast" or "send" will be used to broadcast messages as long as the parameter is a String or a bean.

Next, we'll create a connection factory to instantiate chat clients:
source:ChatClientConnect[]
<1> This factory is a singleton
<2> We'll need the application context, which will be injected into this contructor
<3> Create the WebSocket client for the given URI specifying the username and topic

This bean will help in constructing URIs with parameters:
source:ChatRequest[]
<1> We will create maps from this bean so it needs to be @Introspected
<2> Username of the chat client
<3> Topic of the chat client

=== Tests

test:ChatWebSocketTest[]
<1> We're dealing with chronological messages and the tests will be run potentially concurrently or out-of-order, so ensure that each tests starts with the same state.
<2> Inject our factory to create WebSocket clients
<3> Start the WebSocket server
<4> Set up WebSocket clients for multiple users
<5> Test that the correct messages are automatically sent when users join topics
<6> Test that chats are sent within a topic and not ouside of it except to the special "all" topic
<5> Test that the correct messages are automatically sent when users leave topics

== Next steps

Read more about:

- https://jakarta.ee/specifications/websocket/[Jakarta WebSocket Specifications]
