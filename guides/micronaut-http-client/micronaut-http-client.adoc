= @guideTitle@

@guideIntro@

Authors: @authors@

Micronaut Version: @micronaut@

== Getting Started

In this guide we are going to create a Micronaut app written in @language@ to consume the Bintray API with the Micronaut HTTP Client.

include::{commondir}/common-requirements.adoc[]

include::{commondir}/common-completesolution.adoc[]


include::{commondir}/common-create-app.adoc[]


=== Bintray API

In this guide, you are going to consume the https://bintray.com/docs/api/[Bintray API] from a Micronaut application.

In particular, we consume the https://bintray.com/docs/api/#_get_packages[Get Packages] endpoint.

____
Get a list of packages in the specified repository, optionally specify a starting position and/or a name prefix filter.
____

This API resource can be consumed by both authenticated and anonymous clients.

Initially, you will consume it anonymously, later we will discuss authentication.

Modify `src/main/resources/application.yml` to create some configuration parameters.

resource:application.yml[tag=bintrayconfig]

To encapsulate type-safe configuration retrieval, we use a https://docs.micronaut.io/latest/guide/index.html#configurationProperties[`@ConfigurationProperties`] object:

source:BintrayConfiguration[]

In this guide, you are going to fetch https://bintray.com/micronaut/profiles[Micronaut profiles packages]. Those packages
are used by the https://docs.micronaut.io/latest/guide/index.html#cli[Micronaut CLI].

To consume the Bintray API, you will use Micronaut HTTP Client.


=== Low Level Client

Initially, you will create a Bean which uses the low-level Client API.

Create a POJO to parse the JSON response into an object:

source:BintrayPackage[]

Create `BintrayLowLevelClient`:

source:BintrayLowLevelClient[]

<1> Use `javax.inject.Singleton` to designate a class as a singleton.
<2> Inject `RxClient` via constructor injection.
<3> Inject the previously defined configuration parameters.
<4> Creating HTTP Requests is easy thanks to Micronaut's fluid API.
<5> Use `retrieve` to perform an HTTP request for the given request object and convert the full HTTP response's body into the specified type. e.g. `List<BintrayPackage>`.
<6> The `retrieve` method returns a Flowable which has a firstElement method that returns the first emitted item or nothing

NOTE: Instead of `retrieve` we could have used `jsonStream`. You can use `jsonStream()` to stream arrays of type `application/json` or
JSON streams of type `application/x-json-stream`. If we use `retrieve`, such as in the previous code listing, the operation will not block.
However, it will not return until all the data has been received from the server. In the case of a JSON array that would be the whole array.
However, if you are interested in just the first element of the array, `jsonStream` provides a better alternative since it starts streaming data from the server without needing the whole response.
For example, `jsonStream().firstElement()` will only parse the first item in a JSON array. Hence it is more efficient.



=== Declarative Client

It is time to take a look at Micronaut's support for declarative clients via the Client annotation.

Create `BintrayClient` which clearly illustrates how a declarative Micronaut HTTP Client, which is generated at compile-time, simplifies our code.

source:BintrayClient[]

<1> URL of the remote service
<2> You can use configuration parameter interpolation when you define the path of the GET endpoint.
<3> You can return reactive types, such as an RxJava `Flowable`.



=== Controller

Create a Controller. It uses both (low-level and declarative clients). It showcases several Micronaut's capabilities.

* Micronaut supports any framework that implements Reactive Streams, including RxJava, and Reactor. Thus, you can easily and efficiently
compose multiple HTTP client calls without blocking (which will limit the throughput and scalability of your application).
* Micronaut enables you to consume/produce https://docs.micronaut.io/latest/guide/index.html#clientStreaming[JSON Streams].


source:BintrayController[]

<1> The class is defined as a controller with the https://docs.micronaut.io/latest/api/io/micronaut/http/annotation/Controller.html[@Controller] annotation mapped to the path `/bintray`.
<2> Inject beans via constructor injection.
<3> The https://docs.micronaut.io/latest/api/io/micronaut/http/annotation/Get.html[@Get] annotation is used to map the index method to all requests that use an HTTP GET
<4> The `packagesWithLowLevelClient` returns a Maybe which may or may not emit an item. If an item is not emitted a 404 is returned.
<5> In order to do JSON streaming you can declare a controller method that returns a `application/x-json-stream` of JSON objects.
<6> You can return reactive types, such as an RxJava `Flowable`.


=== Tests

Create a test which verifies both clients work as expected and the controller echoes the output of the Bintray API in a Reactive way.

test:BintrayControllerTest[]

<1> Annotate the class with `@MicronautTest` to let Micronaut starts the embedded server and inject the beans. More info: https://micronaut-projects.github.io/micronaut-test/latest/guide/index.html[https://micronaut-projects.github.io/micronaut-test/latest/guide/index.html].
<2> Inject the `RxStreamingHttpClient` bean in the application context.
<3> Sometimes, receiving just the object is not enough and you need information about the response. In this case, instead of `retrieve` you should use the `exchange` method.
<4> Micronaut makes it easy to parse JSON into Java objects.
<5> Use `status` to check the HTTP status code.
<6> Use `.body()` to retrieve the parsed payload.
<7> Use the `jsonStream` method, which returns a `Flowable`, to consume the endpoint which generates a JSON Stream.


include::{commondir}/common-testApp.adoc[]


== HTTP Client Filter

Often, you need to include the same HTTP headers or URL parameters in a set of requests against a third-party API or when calling another Microservice.

To simplify this, Micronaut includes the ability to define `HttpClientFilter` classes that are applied to all matching HTTP clients.

For real world example, let us provide Bintray Authentication via a `HttpClientFilter`:

____
The Bintray REST API requires an applicative API key. An API key can be obtained from the user profile page. Authentication is achieved using HTTP Basic Authentication with the userâ€™s name as username and the API key as the password. Authenticated REST calls should only be used via HTTPs.
____

Create a Filter:

source:BintrayFilter[]

<1> Supply the pattern you want to match to the `@Filter` annotation.
<2> Bean will not loaded unless configuration properties are set.
<3> Constructor injection of the configuration parameters.
<4> Enhance every request sent to Bintray API providing Basic Authentication.

=== Configuration Parameters

Add your Bintray `username` and `token` to `src/main/resource/application.yml`

[source, yaml]
----
bintray:
  organization: micronaut
  repository: profiles
  apiversion: v1
  username: yourbintrayusername
  token: XXXXXXXXXXX
----

Add to `src/main/resources/logback.xml`, a logger to see Micronaut's HTTP client output.

[source, xml]
----
<logger name="io.micronaut.http.client" level="TRACE"/>
----

If you run again the tests, you will see the that the Filter is invoked and HTTP Basic Auth is used against Bintray API.

[source, bash]
-----
13:21:08.981 [nioEventLoopGroup-1-14] TRACE i.m.http.client.DefaultHttpClient - Authorization: Basic XXXXXXXXXXXXXX
-----


include::{commondir}/common-graal-with-plugins.adoc[]


== Next steps

Visit https://docs.micronaut.io/latest/guide/index.html#httpClient[Micronaut HTTP Client documentation] to learn more.

include::{commondir}/common-helpWithMicronaut.adoc[]

