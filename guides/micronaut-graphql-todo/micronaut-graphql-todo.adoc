common:header.adoc[]

== Getting Started

In this guide, we will create a Micronaut application written in @language@ that uses https://graphql.org/[GraphQL] to create a todo application.

____
GraphQL is a query language for APIs and a runtime for fulfilling those queries with your existing data. GraphQL provides
a complete and understandable description of the data in your API, gives clients the power to ask for exactly what they
need and nothing more, makes it easier to evolve APIs over time, and enables powerful developer tools.
____

common:requirements.adoc[]

common:completesolution.adoc[]

common:create-app-features.adoc[]


== GraphQL

Add the following dependency:

dependency:micronaut-graphql[groupId=io.micronaut.graphql]

By default GraphQL endpoint `/graphql` is enabled so you don't need to add any extra configuration.

=== Describe your schema

Create the file `schema.graphqls` in `src/main/resources` directory:

resource:schema.graphqls[]

<1> Declare a `toDos` function to fetch all the open todos
<2> Declare a `createToDo` function to create a new ToDo
<3> Declare a `completeToDo` function to mark a ToDo as done
<4> Declare a `ToDo` type
<5> Declare an `Author` type

=== ToDo and Author classes

Create `ToDo` and `Author` classes that will mimic the data we want to expose:

source:ToDo[]

source:Author[]

=== Data repository

To keep this example simple, instead of retrieving the information from a database we will keep it in memory and just return it from there. In a real-world example you will use any external storage: relational database, SQL database, etc.

We will create a repository for our `Authors` called `AuthorRepository`:

source:AuthorRepository[]

And another for our ToDos which we will call `ToDoRepository`:

source:ToDoRepository[]

=== Data Fetchers

For each of our queries, we create a `DataFetcher` which we will bind to the GraphQL schema and our domain model, and execute the appropriate queries in our datastore.

==== Accessors

Create class `ToDosDataFetcher` to implement our `toDos` accessor:

source:ToDosDataFetcher[]

==== Mutators

Create class `CreateToDoDataFetcher` for the creation of ToDos:

source:CreateToDoDataFetcher[]

And a class `CompleteToDoDataFetcher` to mark ToDos as complete:

source:CompleteToDoDataFetcher[]

=== Factory

We can then create a factory that will bind the GraphQL schema to the code and types.

source:GraphQLFactory[]

common:runapp.adoc[]

We want to execute a GraphQL query to retrieve all the current ToDos (there will be none to start with)

[source,json]
.Query
----
query {
  toDos {
    title,
    completed,
    author {
       username
    }
  }
}
----

Run the  following curl request:

[source, bash]
----
curl -X POST 'http://localhost:8080/graphql' \
     -H 'content-type: application/json' \
     --data-binary '{"query":"{ toDos { title, completed, author { username } } }"}'
----

[source,json]
----
{"data":{"toDos":[]}}
----

We can then create a ToDo, by issuing a mutation query and return the ID of the newly created ToDo with the query:

[source,json]
.GraphQL Query
----
mutation {
  createToDo(title: "Create GraphQL Guide", author: "Tim Yates") {
    id
  }
}
----

Which translates to this Curl command:

[source, bash]
----
curl -X POST 'http://localhost:8080/graphql' \
     -H 'content-type: application/json' \
     --data-binary '{"query":"mutation { createToDo(title:\"Create GraphQL Guide\", author:\"Tim Yates\") { id } }"}'
----

[source,json]
.Response
----
{"data":{"createToDo":{"id":"1bdf0296-3cc9-4792-836c-ca1443d0d9b3"}}}
----

This new ToDo then appears in our list of all ToDos with `completed` set to false:

[source, bash]
----
curl -X POST 'http://localhost:8080/graphql' \
     -H 'content-type: application/json' \
     --data-binary '{"query":"{ toDos { title, completed, author { username } } }"}'
----

[source,json]
.Response
----
{"data":{"toDos":[{"title":"Create GraphQL Guide","completed":false,"author":{"username":"Tim Yates"}}]}}
----

And we can mark it as completed by using this query with the ID from above (your ID will be different if you are following along)

[source,json]
.GraphQL query
----
mutation {
  completeToDo(id: "1bdf0296-3cc9-4792-836c-ca1443d0d9b3")
}
----

[source,bash]
----
curl -X POST 'http://localhost:8080/graphql' \
     -H 'content-type: application/json' \
     --data-binary '{"query":"mutation { completeToDo(id: \"1bdf0296-3cc9-4792-836c-ca1443d0d9b3\") }"}'
----

[source,json]
.Response
----
{"data":{"completeToDo":true}}
----

And we can then see that this has been persisted in our in-memory model:

[source,bash]
.Query
----
curl -X POST 'http://localhost:8080/graphql' \
     -H 'content-type: application/json' \
     --data-binary '{"query":"{ toDos { title, completed } }"}'
----

[source,json]
.Response
----
{"data":{"toDos":[{"title":"Create GraphQL Guide","completed":true}]}}
----

== Test the application

For testing the application we will use Micronaut HTTP Client to send a `POST` request to the `/graphql` endpoint.
Create the following class:

test:GraphQLControllerTest[]

To run the tests:

:exclude-for-build:maven

[source, bash]
----
./gradlew test
----

Then open `build/reports/tests/test/index.html` in a browser to see the results.

:exclude-for-build:

:exclude-for-build:gradle

[source, bash]
----
./mvnw test
----

:exclude-for-build:

== GraphiQL

As an extra feature that will help you during development, you can enable https://github.com/graphql/graphiql[GraphiQL].
GraphiQL is the GraphQL integrated development environment, and it helps to execute GraphQL queries.

It should only be used for development, so it's not enabled by default. Add the following configuration to enable it:

resource:application.yml[tag=graphiql]

Start the application again and open http://localhost:8080/graphiql in your browser. You can write your GraphQL queries
with integrated auto-completion and execute them to get the results in an easier and nicer way:

image:graphiql-todo.png[]

common:graal-with-plugins.adoc[]

:exclude-for-languages:groovy

Start the native image and execute the same curl request as before. You can also use the included GraphiQL browser to
execute the queries.

:exclude-for-languages:

== Next steps

Take a look at the https://micronaut-projects.github.io/micronaut-graphql/latest/guide/[Micronaut GraphQL documentation].

common:helpWithMicronaut.adoc[]
