common:header-top.adoc[]

== Getting Started

In this guide, we will create three microservices, build containerized versions and deploy them with https://kubernetes.io/[Kubernetes]. We will use Kubernetes Service discovery and Distributed configuration to wire up our microservices.

____
Kubernetes is a portable, extensible, open source platform for managing containerized workloads and services, that facilitates both declarative configuration and automation. It has a large, rapidly growing ecosystem. Kubernetes services, support, and tools are widely available.
____

You will discover how the Micronaut framework eases Kubernetes integration.

external:micronaut-k8s/requirements.adoc[]
* Local Kubernetes cluster. We will use https://minikube.sigs.k8s.io/docs/[Minikube] in this guide.

common:completesolution.adoc[]

== Writing the Apps

Let's describe the microservices you will build through the guide.

* `users` - This microservice contains customers data that can place orders on items, also a new customer can be created. Microservice requires Basic authentication to access it.

* `orders` - This microservice contains all orders that customers have created as well as available items that customers can order. Also this microservice enables the creation of new orders. Microservice requires Basic authentication to access it.

* `api` - This microservice acts as a gateway to the `orders` and `users` services. It combines results from both services and checks data when customers create a new order.

Initially we will hard-code the URLs of the `orders` and `users` services in the `api` service. Additionally, we will hard-code credentials (username and password) into every microservice configuration that are required for Basic authentication.

In the second part of this guide we will use a Kubernetes discovery service and Kubernetes configuration maps to dynamically resolve the URLs of the `orders` and `users` microservices  and get authentication credentials. The microservices call the Kubernetes API to register when they start up and then resolve placeholders inside the microservices' configurations.

common:annotationprocessors.adoc[]

=== Users Microservice

Create the `users` microservice using the https://docs.micronaut.io/latest/guide/#cli[Micronaut Command Line Interface] or with https://launch.micronaut.io[Micronaut Launch].

[source,bash]
----
mn @users:cli-command@          \
    --features=@users:features@ \
    --build=@build@             \
    --lang=@lang@               \
    --jdk=@minJdk@              \
    example.micronaut.users
----

common:build-lang-arguments.adoc[]

If you use Micronaut Launch, select Micronaut Application as application type and add the `discovery-kubernetes`, `management`, `security`, `serialization-jackson`, `kubernetes` and `graalvm` features.

The previous command creates a directory named _users_ containing Micronaut application with a package named `example.micronaut`.

diffLink:[app=users]

Create a package named `controllers` and create a `UsersController` class to handle incoming HTTP requests for the `users` microservice:

source:controllers/UsersController[app=users]
callout:controller[number=1,arg0=/users]
<2> Annotate with `io.micronaut.security.Secured` to configure secured access. The `isAuthenticated()` expression will allow access only to authenticated users.
callout:post[number=3,arg0=add,arg1=/users]
callout:get[number=4,arg0=findById,arg1=/users/{id}]
callout:get[number=5,arg0=getUsers,arg1=/users]

Create package named `models` where we will put our data beans.

:exclude-for-languages:groovy,kotlin
The previous `UsersController` controller uses a `User` object to represent the customer. Create the `User` record
:exclude-for-languages:

:exclude-for-languages:java
The `UsersController` class uses a `User` object to represent customer. Create the `User` class
:exclude-for-languages:

source:models/User[app=users]
callout:serdeable[1]
<2> ID will be generated by application.

Create package named `auth` where you will check basic authentication credentials.

The `Credentials` class will load and store credentials (username and password) from a configuration file.

source:auth/Credentials[app=users]
callout:configuration-properties[1]

The `CredentialsChecker` class, as the name suggests, will check if the provided credentials inside the HTTP request's `Authorization` header are the same as those that are stored inside the `Credentials` class that we created above.

source:auth/CredentialsChecker[app=users]
callout:singleton[1]

{empty} +

==== Write tests to verify application logic

Create the `UsersClient`, a declarative Micronaut HTTP Client for testing:

test:UsersClient[app=users]
callout:client[1]

`HealthTest` checks that there is `/health` endpoint that is required for service discovery.

test:HealthTest[app=users]
callout:micronaut-test[1]
callout:http-client[2]

`UsersControllerTest` tests endpoints inside the `UserController`.

test:UsersControllerTest[app=users]
callout:micronaut-test[1]

Edit _application.yml_

resource:application.yml[app=users]
<1> Placeholder for username that will be populated by Kubernetes.
<2> Placeholder for password that will be populated by Kubernetes.

Edit the _bootstrap.yml_ file in the _resources_ directory to https://docs.micronaut.io/latest/guide/#bootstrap[enable distributed configuration].
Change the default contents to the following:

resource:bootstrap.yml[app=users]
<1> Set `microanut.config-client.enabled: true`  to read and resolve configuration from distributed sources.
<2> Set `kubernetes.client.secrets.enabled: true` to enable Kubernetes secrets as distributed source.
<3> Set `kubernetes.client.secrets.use-api: true` to use the Kubernetes API to fetch the configuration.

common:default-dev-environment-application-dev-yaml.adoc[]

resource:application-dev.yml[app=users]
<1> Configure the application to listen on port 8081.
<2> Hardcoded username for the development environment.
<3> Hardcoded password for the development environment.

Create a file named _bootstrap-dev.yml_ to disable distributed configuration in the dev environment:

resource:bootstrap-dev.yml[app=users]
<1> Disable the Kubernetes secrets client.

Create a file named _application-test.yml_ for use in the test environment:

testResource:application-test.yml[app=users]
<1> Hardcoded username for the test environment.
<2> Hardcoded password for the test environment.

Run the unit test:

:exclude-for-build:maven

[source, bash]
.users
----
./gradlew test
----

:exclude-for-build:

:exclude-for-build:gradle

[source, bash]
.users
----
./mvnw test
----

:exclude-for-build:

{empty} +

==== Running the application

Run the `users` microservice:

:exclude-for-build:maven

[source, bash]
.users
----
 MICRONAUT_ENVIRONMENTS=dev ./gradlew run
----

:exclude-for-build:

:exclude-for-build:gradle

[source, bash]
.users
----
 MICRONAUT_ENVIRONMENTS=dev ./mvnw mn:run
----

:exclude-for-build:

[source]
----
14:28:34.034 [main] INFO  io.micronaut.runtime.Micronaut - Startup completed in 499ms. Server Running: http://localhost:8081
----

=== Orders Microservice

Create the `orders` microservice using the https://docs.micronaut.io/latest/guide/#cli[Micronaut Command Line Interface] or with https://launch.micronaut.io[Micronaut Launch].

[source,bash]
----
mn @orders:cli-command@        \
  --features=@orders:features@ \
  --build=@build@              \
  --lang=@lang@                \
  --jdk=@minJdk@               \
example.micronaut.orders
----

common:build-lang-arguments.adoc[]

If you use Micronaut Launch, select Micronaut Application as application type and add the `discovery-kubernetes`, `management`, `security`, `serialization-jackson`, `kubernetes` and `graalvm` features.

The previous command creates a directory named _orders_ containing a Micronaut application with a package named `example.micronaut`.

diffLink:[app=orders]

Create package named `controllers` and create the `OrdersController` and `ItemsController` classes to handle incoming HTTP requests to the `orders` microservice:

source:controllers/OrdersController[app=orders]
callout:controller[number=1,arg0=/orders]
<2> Annotate with `io.micronaut.security.Secured` to configure secured access. The `isAuthenticated()` expression will allow access only to authenticated users.
callout:get[number=3,arg0=findById,arg1=/orders/{id}]
callout:get[number=4,arg0=getOrders,arg1=/orders]
callout:post[number=5,arg0=createOrder,arg1=/orders]

source:controllers/ItemsController[app=orders]
callout:controller[number=1,arg0=/items]
<2> Annotate with `io.micronaut.security.Secured` to configure secured access. The `isAuthenticated()` expression will allow access only to authenticated users.
callout:get[number=3,arg0=findById,arg1=/items/{id}]
callout:get[number=4,arg0=getItems,arg1=/items]

Create package named `models` where you will put your data beans.

:exclude-for-languages:groovy,kotlin
The `OrdersController` and `ItemsController` classes uses `Order` and `Item`  objects to represent customer orders. Create the `Order` record:
:exclude-for-languages:

:exclude-for-languages:java
The previous `OrdersController` and `ItemsController` controller uses `Order` and `Item`  objects to represent customer orders. Create the `Order` class:
:exclude-for-languages:

source:models/Order[app=orders]
callout:serdeable[1]
<2> ID will be generated by application.
<3> The `List` of `Item` class will be populated by the server and will be only visible in sever responses.
<4> List of item_ids will be provided by client requests.

:exclude-for-languages:groovy,kotlin
Create the `Item` record:
:exclude-for-languages:

:exclude-for-languages:java
Create the `Item` class:
:exclude-for-languages:

source:models/Item[app=orders]
callout:serdeable[1]

Create package named `auth` where you will check basic authentication credentials.

The `Credentials` class will load and store credentials (username and password) from configuration files.

source:auth/Credentials[app=orders]
callout:configuration-properties[1]

The `CredentialsChecker` class, as name suggests, will check if provided credentials inside an HTTP request's `Authorization` header are the same as those that are stored inside `Credentials` class that we created above.

source:auth/CredentialsChecker[app=orders]
callout:singleton[1]

{empty} +

==== Write tests to verify application logic

Create the `OrderItemClient`, a declarative Micronaut HTTP Client for testing:

test:OrderItemClient[app=orders]
callout:client[1]

`HealthTest` checks that there is `/health` endpoint that is required for service discovery.

test:HealthTest[app=orders]
callout:micronaut-test[1]
callout:http-client[2]

`ItemsControllerTest` tests endpoints inside the `ItemController`.

test:ItemsControllerTest[app=orders]
callout:micronaut-test[1]

`OrdersControllerTest` tests endpoints inside the `OrdersController`.

test:OrdersControllerTest[app=orders]
callout:micronaut-test[1]

Edit _application.yml_ so it contains:

resource:application.yml[app=orders]
<1> Placeholder for username that will be populated by Kubernetes.
<2> Placeholder for password that will be populated by Kubernetes.

Edit _bootstrap.yml_ file in
the _resources_ directory to https://docs.micronaut.io/latest/guide/#bootstrap[enable distributed configuration].
Change it to the following:

resource:bootstrap.yml[app=orders]
<1> Set `microanut.config-client.enabled: true` to read and resolve configuration from distributed sources.
<2> Set `kubernetes.client.secrets.enabled: true` to enable Kubernetes secrets as distributed source.
<3> Set `kubernetes.client.secrets.use-api: true` to use Kubernetes API to fetch configuration.


common:default-dev-environment-application-dev-yaml.adoc[]

resource:application-dev.yml[app=orders]
<1> Configure the application to listen on port 8082.
<2> Hardcoded username for development environment.
<3> Hardcoded password for development environment.

Create a file named _bootstrap-dev.yml_ to disable distributed configuration in the dev environment:

resource:bootstrap-dev.yml[app=orders]
<1> Disable Kubernetes secrets client.

Create a file named _application-test.yml_ to be used in the test environment:

testResource:application-test.yml[app=orders]
<1> Hardcoded username for development environment.
<2> Hardcoded password for development environment.

Run the unit test:

:exclude-for-build:maven

[source, bash]
.orders
----
./gradlew test
----

:exclude-for-build:

:exclude-for-build:gradle

[source, bash]
.orders
----
./mvnw test
----

:exclude-for-build:

{empty} +

==== Running the application

Run the `orders` microservice:

:exclude-for-build:maven

[source, bash]
.orders
----
MICRONAUT_ENVIRONMENTS=dev ./gradlew run
----

:exclude-for-build:

:exclude-for-build:gradle

[source, bash]
.orders
----
MICRONAUT_ENVIRONMENTS=dev ./mvnw mn:run
----

:exclude-for-build:

[source]
----
14:28:34.034 [main] INFO  io.micronaut.runtime.Micronaut - Startup completed in 499ms. Server Running: http://localhost:8082
----

=== API (Gateway) Microservice

Create the `api` microservice using the https://docs.micronaut.io/latest/guide/#cli[Micronaut Command Line Interface] or with https://launch.micronaut.io[Micronaut Launch].

[source,bash]
----
mn @api:cli-command@         \
   --features=@api:features@ \
   --build=@build@           \
   --lang=@lang@             \
   --jdk=@minJdk@            \
    example.micronaut.api
----

common:build-lang-arguments.adoc[]

If you use Micronaut Launch, select Micronaut Application as application type and add the `discovery-kubernetes`, `management`, `kubernetes`, `serialization-jackson`, `mockito` and `graalvm` features.

The previous command creates a directory named _api_ containing a Micronaut application with a package named `example.micronaut`.

diffLink:[app=api]

Create a package named `controllers` and create a `GatewayController` class to handle incoming HTTP requests to the `api` microservice:

source:controllers/GatewayController[app=api]
callout:controller[number=1,arg0=/api]
callout:executes-on[2]
callout:get[number=3,arg0=getUserById,arg1=/users/{id}]
callout:get[number=4,arg0=getOrdersById,arg1=/orders/{id}]
callout:get[number=5,arg0=getItemsById,arg1=/items/{id}]
callout:get[number=6,arg0=getUsers,arg1=/users]
callout:get[number=7,arg0=getItems,arg1=/items]
callout:get[number=8,arg0=getOrders,arg1=/orders]
callout:post[number=9,arg0=createUser,arg1=/users]
callout:post[number=10,arg0=createOrder,arg1=/orders]

Create package named `models` where you will put your data beans.

:exclude-for-languages:groovy,kotlin
The `GatewayController` and `ItemsController` classes use `User`, `Order`, and `Item` to represent customer orders. Create the `User` record:
:exclude-for-languages:

:exclude-for-languages:java
The previous `GatewayController` and `ItemsController` controller uses `User`, `Order` and `Item` to represent customer orders. Create the `User` class:
:exclude-for-languages:

source:models/User[app=api]
callout:serdeable[1]

:exclude-for-languages:groovy,kotlin
Create the `Order` record:
:exclude-for-languages:

:exclude-for-languages:java
Create the `Order` class:
:exclude-for-languages:

source:models/Order[app=api]
callout:serdeable[1]

:exclude-for-languages:groovy,kotlin
Create the `Item` record:
:exclude-for-languages:

:exclude-for-languages:java
Create the `Item` class:
:exclude-for-languages:

source:models/Item[app=api]
callout:serdeable[1]

Create a package named `clients` where you will put the HTTP Clients to call the `users` and `orders` microservices.

Create a `UserClient` for the `users` microservice.
source:clients/UsersClient[app=api]
callout:client[1]

Create an `OrdersClient` for the `orders` microservice.
source:clients/OrdersClient[app=api]
callout:client[1]

Create a package named `auth` where we will check basic authentication credentials.

Create a `Credentials` class that will load the username and password from configuration that will be needed for comparison.

source:auth/Credentials[app=api]
callout:configuration-properties[1]

Create an `AuthClientFilter` class that is a client filter applied to every client. It adds basic authentication header with credentials that are stored in the `Credentials` class.

source:auth/AuthClientFilter[app=api]

Create a class named `ErrorExceptionHandler` in the `example.micronaut` package. `ErrorExceptionHandler` will propagate errors from the `orders` and `users` microservices.
source:ErrorExceptionHandler[app=api]
callout:singleton[1]

{empty} +

==== Write tests to verify application logic

Create a `GatewayClient`, a declarative Micronaut HTTP Client for testing:

test:GatewayClient[app=api]
callout:client[1]

`HealthTest` checks that there is `/health` endpoint that is required for service discovery.

test:HealthTest[app=api]
callout:micronaut-test[1]
callout:http-client[2]

`GatewayControllerTest` tests endpoints inside the `GatewayController`.

test:GatewayControllerTest[app=api]
callout:micronaut-test[1]

Edit _application.yml_

resource:application.yml[app=api]
<1> Placeholder for username that will be populated by Kubernetes.
<2> Placeholder for password that will be populated by Kubernetes.

Edit the _bootstrap.yml_ file in the _resources_ directory to https://docs.micronaut.io/latest/guide/#bootstrap[enable distributed configuration] so it looks like the following:

resource:bootstrap.yml[app=api]
<1> Set `microanut.config-client.enabled: true` to read and resolve configuration from distributed sources.
<2> Set `kubernetes.client.secrets.enabled: true` to enable Kubernetes secrets as a distributed source.
<3> Set `kubernetes.client.secrets.use-api: true` to use the  Kubernetes API to fetch configuration.

common:default-dev-environment-application-dev-yaml.adoc[]

resource:application-dev.yml[app=api]
<1> Hardcoded username for development environment.
<2> Hardcoded password for development environment.

Create a file named _bootstrap-dev.yml_ to disable distributed configuration in the dev environment:

resource:bootstrap-dev.yml[app=api]
<1> URL of the `users` microservice
<2> URL of the `orders` microservice
<3> Disable Kubernetes secrets client.

Create a file named _application-test.yml_ to be used in the test environment:

testResource:application-test.yml[app=api]
<1> Hardcoded username for development environment.
<2> Hardcoded password for development environment.

Run the unit test:

:exclude-for-build:maven

[source, bash]
.api
----
./gradlew test
----

:exclude-for-build:

:exclude-for-build:gradle

[source, bash]
.api
----
./mvnw test
----

:exclude-for-build:

{empty} +

==== Running the application

Run `api` microservice:

:exclude-for-build:maven

[source, bash]
.api
----
MICRONAUT_ENVIRONMENTS=dev ./gradlew run
----

:exclude-for-build:

:exclude-for-build:gradle

[source, bash]
.api
----
MICRONAUT_ENVIRONMENTS=dev ./mvnw mn:run
----

:exclude-for-build:

[source]
----
14:28:34.034 [main] INFO  io.micronaut.runtime.Micronaut - Startup completed in 499ms. Server Running: http://localhost:8080
----

=== Test integration between applications

Store the URL of the `api` microservice in the `API_URL` environment variable.

[source,bash]
----
export API_URL=http://localhost:8080
----

external:micronaut-k8s/verify.adoc[]

== Kubernetes and the Micronaut framework

In this chapter we will first create the necessary Kubernetes resources for our microservices that will make them work properly then we will configure, build container images and deploy each of the microservices that we created on the local Kubernetes cluster.

Create a filed named _auth.yml_  that will service role for microservices that have secret configurations.

[source, yaml]
.auth.yml
----
include::{sourceDir}/micronaut-k8s/@sourceDir@/auth.yml[]
----
<1> We create a namespace named `micronaut-k8s`.
<2> We create a service account named `micronaut-service`.
<3> We create a role named `micronaut_service_role`.
<4> We bind  the `micronaut_service_role` role to the `micronaut-service` service account.
<5> We create a secret named `mysecret`.
<6> Base64 value of the username secret that will be used by the microservices.
<7> Base64 value of the password secret that will be used by the microservices.

Run the next command to create the resources described above:

[source,bash]
----
kubectl apply -f auth.yml
----

Before we start deploying each service, ensure that Docker daemon is configured to use Kubernetes.
If you are using https://minikube.sigs.k8s.io/[Minikube] run the next command to switch the docker daemon to use Minikube.

[source,bash]
----
eval $(minikube docker-env)
----

=== Users Microservice

external-template:micronaut-k8s/micronaut-k8s-docker.adoc[arg0=users]

Edit the file named _k8s.yml_ inside the `users` microservice.

[source, yaml]
./users/k8s.yml
----
include::{sourceDir}/micronaut-k8s/@sourceDir@/users/k8s.yml[]
----
<1> The service name that we created in the _auth.yaml_ file.
<2> The name of the container image for deployment.
<3> The imagePullPolicy is set to Never. We will always use local one that we built in previous step.
<4> Name of a service, required for service discovery.
<5> Micronaut default port on which application is running.

external-template:micronaut-k8s/k8s-deploy-service.adoc[arg0=users]

[source,text]
----
deployment.apps/users created
service/users created
----

=== Orders Microservice

external-template:micronaut-k8s/micronaut-k8s-docker.adoc[arg0=orders]

Edit the file named _k8s.yml_ inside the `orders` microservice.

[source, yaml]
./orders/k8s.yml
----
include::{sourceDir}/micronaut-k8s/@sourceDir@/orders/k8s.yml[]
----
<1> The service name that we created in the _auth.yaml_ file.
<2> The name of the container image for deployment.
<3> The imagePullPolicy is set to Never. We will always use local one that we built in previous step.
<4> Name of a service, required for service discovery.
<5> Micronaut default port on which application is running.

external-template:micronaut-k8s/k8s-deploy-service.adoc[arg0=orders]

=== API (Gateway) Microservice

external-template:micronaut-k8s/micronaut-k8s-docker.adoc[arg0=api]

Edit the file named _k8s.yml_ inside the `api` microservice.

[source, yaml]
./api/k8s.yml
----
include::{sourceDir}/micronaut-k8s/@sourceDir@/api/k8s.yml[]
----
<1> The service name that we created in the _auth.yaml_ file.
<2> The name of the container image for deployment.
<3> The imagePullPolicy is set to Never. We will always use local one that we built in previous step.
<4> Name of a service, required for service discovery.
<5> Micronaut default port on which application is running.

external-template:micronaut-k8s/k8s-deploy-service.adoc[arg0=api]

=== Test integration between applications deployed on Kubernetes

Run the next command to check status of the pods and make sure that all of them have the status "Running":

[source,bash]
----
kubectl get pods -n=micronaut-k8s
----

[source,text]
----
NAME                      READY   STATUS    RESTARTS   AGE
api-774fd667b9-dmws4      1/1     Running   0          24s
orders-74ff4fcbc4-dnfbw   1/1     Running   0          19s
users-9f46dd7c6-vs8z7     1/1     Running   0          13s
----

Run the next command to check the status of the microservices:

[source,bash]
----
kubectl get services -n=micronaut-k8s
----

==== Minikube

For Minikube the output should be similar to the following:

[source,text]
----
NAME     TYPE           CLUSTER-IP       EXTERNAL-IP   PORT(S)          AGE
api      LoadBalancer   10.110.42.201    <pending>     8080:32601/TCP   18s
orders   NodePort       10.105.43.19     <none>        8080:31033/TCP   21s
users    NodePort       10.104.130.114   <none>        8080:31482/TCP   26s
----

NOTE: By default, the EXTERNAL-IP address  of the LoadBalancer service inside Minikube will be in the <pending> state. If you want to assign an external ip you have to run the `minikube tunnel` command.

Run the next command to retrieve the URL of the `api` microservice:

[source,bash]
----
export API_URL=$(minikube service api -n=micronaut-k8s --url)
----

==== Docker Desktop

For Docker Desktop's Kubernetes integration the output should be similar to the following.  Notice the external-ip is `localhost`:

[source,text]
----
NAME     TYPE           CLUSTER-IP       EXTERNAL-IP   PORT(S)          AGE
api      LoadBalancer   10.108.205.248   localhost     8080:31516/TCP   9m23s
orders   NodePort       10.98.120.224    <none>        8080:31566/TCP   9m39s
users    NodePort       10.109.155.86    <none>        8080:30545/TCP   10m
----

So for Docker Desktop the `API_URL` should be set to `http://localhost:8080`.

external:micronaut-k8s/verify.adoc[]

== Cleaning Up

To delete all resources that were created in this guide run next command.

[source,bash]
----
kubectl delete namespaces micronaut-k8s
----

== Next steps

Read more about https://kubernetes.io/docs/home/[Kubernetes].

Read more about https://micronaut-projects.github.io/micronaut-kubernetes/snapshot/guide/[Micronaut Kubernetes] module.
